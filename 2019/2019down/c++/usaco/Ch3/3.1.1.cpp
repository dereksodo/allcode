/*ID: zjd32151TASK: agrinetLANG: C++*/#include <iostream>#include <cstring>#include <cstdlib>#include <set>#include <vector>#include <map>#include <cstdio>#include <utility>#include <algorithm>#include <cmath>#include <queue>#include <stack>#include <cassert>#include <climits>using namespace std;typedef long long ll;#define DEBUG#ifdef DEBUG	#define debug printf#else	#define debug(...)#endifconst int maxn = 105;struct edge{	int from,to,value;	const bool operator < (const edge &b)const	{		return value < b.value;	}	void display()	{		// printf("%d %d %d\n",from,to,value);	}};int father[maxn];int findfather(int u){	if(father[u] == u)	{		return u;	}	return father[u] = findfather(father[u]);}void join(int u,int v){	father[findfather(u)] = findfather(v);}edge e[maxn * maxn];int main(int argc, char const *argv[]){	freopen("agrinet.in","r",stdin);	freopen("agrinet.out","w",stdout);	int n;	cin>>n;	int cnt = 0;	for(int i = 1;i <= n; ++i)	{		for(int j = 1;j <= n; ++j)		{			int x;			scanf("%d",&x);			if(x != 0)			{				e[++cnt].from = i;				e[cnt].to = j;				e[cnt].value = x;			}		}	}	for(int i = 1;i <= n; ++i)	{		father[i] = i;	}	sort(e + 1,e + cnt + 1);	for(int i = 1;i <= cnt; ++i)	{		e[i].display();	}	int MST = 0;	int num = 0;	for(int i = 1;i <= cnt && num < n; ++i)	{		int x = e[i].from;		int y = e[i].to;		if(findfather(x) != findfather(y))		{			// printf("join(%d,%d)\n",x,y);			join(x,y);			MST += e[i].value;			num++;		}	}	cout<<MST<<endl;	return 0;}